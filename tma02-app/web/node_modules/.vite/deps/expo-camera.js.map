{
  "version": 3,
  "sources": ["../../../../node_modules/expo-camera/src/Camera.tsx", "../../../../node_modules/expo-camera/src/ExponentCamera.web.tsx", "../../../../node_modules/expo-camera/src/Camera.types.ts", "../../../../node_modules/expo-camera/src/WebUserMediaManager.ts", "../../../../node_modules/expo-camera/src/ExponentCameraManager.web.ts", "../../../../node_modules/expo-camera/src/WebCameraUtils.ts", "../../../../node_modules/expo-camera/src/WebCapabilityUtils.ts", "../../../../node_modules/expo-camera/src/WebConstants.ts", "../../../../node_modules/expo-camera/src/useWebCameraStream.ts", "../../../../node_modules/expo-camera/src/useWebQRScanner.ts", "../../../../node_modules/expo-camera/src/utils/props.ts"],
  "sourcesContent": ["import { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { findNodeHandle } from 'react-native';\n\nimport {\n  CameraCapturedPicture,\n  CameraOrientation,\n  CameraPictureOptions,\n  CameraProps,\n  CameraRecordingOptions,\n  CameraType,\n  ConstantsType,\n  PermissionResponse,\n  VideoCodec,\n} from './Camera.types';\nimport ExponentCamera from './ExponentCamera';\nimport CameraManager from './ExponentCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS = {};\n\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  const pictureOptions: CameraPictureOptions =\n    !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n  if (pictureOptions.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options?: CameraRecordingOptions): CameraRecordingOptions {\n  let recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class Camera extends React.Component<CameraProps> {\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return await CameraManager.isAvailableAsync();\n  }\n\n  /**\n   * Returns a list of camera types `['front', 'back']`. This is useful for desktop browsers which only have front-facing cameras.\n   * @platform web\n   */\n  static async getAvailableCameraTypesAsync(): Promise<CameraType[]> {\n    if (!CameraManager.getAvailableCameraTypesAsync) {\n      throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n    }\n\n    return await CameraManager.getAvailableCameraTypesAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return await CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  static Constants: ConstantsType = {\n    Type: CameraManager.Type,\n    FlashMode: CameraManager.FlashMode,\n    AutoFocus: CameraManager.AutoFocus,\n    WhiteBalance: CameraManager.WhiteBalance,\n    VideoQuality: CameraManager.VideoQuality,\n    VideoStabilization: CameraManager.VideoStabilization || {},\n    VideoCodec: CameraManager.VideoCodec,\n  };\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraProps = {\n    zoom: 0,\n    ratio: '4:3',\n    focusDepth: 0,\n    faceDetectorSettings: {},\n    type: CameraManager.Type.back,\n    autoFocus: CameraManager.AutoFocus.on,\n    flashMode: CameraManager.FlashMode.off,\n    whiteBalance: CameraManager.WhiteBalance.auto,\n  };\n\n  // @needsAudit\n  /**\n   * @deprecated Use `getCameraPermissionsAsync` or `getMicrophonePermissionsAsync` instead.\n   * Checks user's permissions for accessing camera.\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"getPermissionsAsync()\" is now deprecated. Please use \"getCameraPermissionsAsync()\" or \"getMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.getPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify both `NSCameraUsageDescription` and `NSMicrophoneUsageDescription` entries in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   * @deprecated Use `requestCameraPermissionsAsync` or `requestMicrophonePermissionsAsync` instead.\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestCameraPermissionsAsync()\" or \"requestMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.requestPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing camera.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify an `NSCameraUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the camera.\n   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useCameraPermissions();\n   * ```\n   */\n  static useCameraPermissions = createPermissionHook({\n    getMethod: Camera.getCameraPermissionsAsync,\n    requestMethod: Camera.requestCameraPermissionsAsync,\n  });\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing microphone.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing the microphone.\n   * On iOS this will require apps to specify an `NSMicrophoneUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the microphone.\n   * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useMicrophonePermissions();\n   * ```\n   */\n  static useMicrophonePermissions = createPermissionHook({\n    getMethod: Camera.getMicrophonePermissionsAsync,\n    requestMethod: Camera.requestMicrophonePermissionsAsync,\n  });\n\n  _cameraHandle?: number | null;\n  _cameraRef?: React.Component | null;\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  // @needsAudit\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview. Anyway on Android it is essential\n   * to set ratio prop to get a picture with correct dimensions.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on iOS,\n   * Android, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image. `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64--prepend that with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example. `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image--the names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copyAsync`](filesystem.md#filesystemcopyasyncoptions)\n   * > to make a permanent copy of the image.\n   */\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture> {\n    const pictureOptions = ensurePictureOptions(options);\n\n    return await CameraManager.takePicture(pictureOptions, this._cameraHandle);\n  }\n\n  /**\n   * Get aspect ratios that are supported by the device and can be passed via `ratio` prop.\n   * @return Returns a Promise that resolves to an array of strings representing ratios, eg. `['4:3', '1:1']`.\n   * @platform android\n   */\n  async getSupportedRatiosAsync(): Promise<string[]> {\n    if (!CameraManager.getSupportedRatios) {\n      throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n    }\n\n    return await CameraManager.getSupportedRatios(this._cameraHandle);\n  }\n\n  /**\n   * Get picture sizes that are supported by the device for given `ratio`.\n   * @param ratio A string representing aspect ratio of sizes to be returned.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(ratio?: string): Promise<string[]> {\n    if (!CameraManager.getAvailablePictureSizes) {\n      throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n    }\n    return await CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions): Promise<{ uri: string }> {\n    if (!CameraManager.record) {\n      throw new UnavailabilityError('Camera', 'recordAsync');\n    }\n\n    const recordingOptions = ensureRecordingOptions(options);\n    return await CameraManager.record(recordingOptions, this._cameraHandle);\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   */\n  stopRecording() {\n    if (!CameraManager.stopRecording) {\n      throw new UnavailabilityError('Camera', 'stopRecording');\n    }\n\n    CameraManager.stopRecording(this._cameraHandle);\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  pausePreview() {\n    if (!CameraManager.pausePreview) {\n      throw new UnavailabilityError('Camera', 'pausePreview');\n    }\n\n    CameraManager.pausePreview(this._cameraHandle);\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  resumePreview() {\n    if (!CameraManager.resumePreview) {\n      throw new UnavailabilityError('Camera', 'resumePreview');\n    }\n\n    CameraManager.resumePreview(this._cameraHandle);\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onResponsiveOrientationChanged = ({\n    nativeEvent,\n  }: {\n    nativeEvent: { orientation: CameraOrientation };\n  }) => {\n    if (this.props.onResponsiveOrientationChanged) {\n      this.props.onResponsiveOrientationChanged(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref?: React.Component) => {\n    if (ref) {\n      this._cameraRef = ref;\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      } else {\n        this._cameraHandle = findNodeHandle(ref);\n      }\n    } else {\n      this._cameraRef = null;\n      this._cameraHandle = null;\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n\n    const onBarCodeScanned = this.props.onBarCodeScanned\n      ? this._onObjectDetected(this.props.onBarCodeScanned)\n      : undefined;\n\n    const onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n    return (\n      <ExponentCamera\n        {...nativeProps}\n        ref={this._setReference}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarCodeScanned={onBarCodeScanned}\n        onFacesDetected={onFacesDetected}\n        onPictureSaved={_onPictureSaved}\n        onResponsiveOrientationChanged={this._onResponsiveOrientationChanged}\n      />\n    );\n  }\n}\n\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  getCameraPermissionsAsync,\n  requestCameraPermissionsAsync,\n  getMicrophonePermissionsAsync,\n  requestMicrophonePermissionsAsync,\n} = Camera;\n", "import { CodedError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = React.forwardRef(\n  (\n    { type, pictureSize, poster, ...props }: CameraNativeProps & { children?: React.ReactNode },\n    ref: React.Ref<ExponentCameraRef>\n  ) => {\n    const video = React.useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, type as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = React.useMemo<boolean>(() => {\n      return !!(\n        props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned\n      );\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: props.barCodeScannerSettings?.interval,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n      onScanned(event) {\n        if (props.onBarCodeScanned) {\n          props.onBarCodeScanned(event);\n        }\n      },\n      // onError: props.onMountError,\n    });\n\n    // const [pause, setPaused]\n\n    React.useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(ratio: string): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = React.useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          // webkitPlaysinline\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = React.forwardRef(\n  (\n    props: React.ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: React.Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n", "import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionExpiration,\n  PermissionHookOptions,\n} from 'expo-modules-core';\nimport type { ViewProps } from 'react-native';\n\nexport enum CameraType {\n  front = 'front',\n  back = 'back',\n}\n\nexport enum FlashMode {\n  on = 'on',\n  off = 'off',\n  auto = 'auto',\n  torch = 'torch',\n}\n\nexport enum AutoFocus {\n  on = 'on',\n  off = 'off',\n  /**\n   * @platform web\n   */\n  auto = 'auto',\n  /**\n   * @platform web\n   */\n  singleShot = 'singleShot',\n}\n\nexport enum WhiteBalance {\n  auto = 'auto',\n  /**\n   * @platform android\n   * @platform ios\n   */\n  sunny = 'sunny',\n  /**\n   * @platform android\n   * @platform ios\n   */\n  cloudy = 'cloudy',\n  /**\n   * @platform android\n   * @platform ios\n   */\n  shadow = 'shadow',\n  /**\n   * @platform android\n   * @platform ios\n   */\n  incandescent = 'incandescent',\n  /**\n   * @platform android\n   * @platform ios\n   */\n  fluorescent = 'fluorescent',\n  /**\n   * @platform web\n   */\n  continuous = 'continuous',\n  /**\n   * @platform web\n   */\n  manual = 'manual',\n}\n\nexport enum ImageType {\n  png = 'png',\n  jpg = 'jpg',\n}\n\n/**\n * This option specifies what codec to use when recording a video.\n * @platform ios\n */\nexport enum VideoCodec {\n  H264 = 'avc1',\n  HEVC = 'hvc1',\n  JPEG = 'jpeg',\n  AppleProRes422 = 'apcn',\n  AppleProRes4444 = 'ap4h',\n}\n\n/**\n * This option specifies the stabilization mode to use when recording a video.\n * @platform ios\n */\nexport enum VideoStabilization {\n  off = 'off',\n  standard = 'standard',\n  cinematic = 'cinematic',\n  auto = 'auto',\n}\n\n// @docsMissing\nexport enum VideoQuality {\n  '2160p' = '2160p',\n  '1080p' = '1080p',\n  '720p' = '720p',\n  '480p' = '480p',\n  '4:3' = '4:3',\n}\n\nexport enum CameraOrientation {\n  portrait = 1,\n  portraitUpsideDown = 2,\n  landscapeLeft = 3,\n  landscapeRight = 4,\n}\n\n// @docsMissing\n/**\n * @hidden We do not expose related web methods in docs.\n * @platform web\n */\nexport type ImageSize = {\n  width: number;\n  height: number;\n};\n\n// @docsMissing\n/**\n * @hidden We do not expose related web methods in docs.\n * @platform web\n */\nexport type WebCameraSettings = {\n  autoFocus?: string;\n  flashMode?: string;\n  whiteBalance?: string;\n  exposureCompensation?: number;\n  colorTemperature?: number;\n  iso?: number;\n  brightness?: number;\n  contrast?: number;\n  saturation?: number;\n  sharpness?: number;\n  focusDistance?: number;\n  zoom?: number;\n};\n\n// @needsAudit\nexport type CameraCapturedPicture = {\n  /**\n   * Captured image width.\n   */\n  width: number;\n  /**\n   * Captured image height.\n   */\n  height: number;\n  /**\n   * On web, the value of `uri` is the same as `base64` because file system URLs are not supported in the browser.\n   */\n  uri: string;\n  /**\n   * A Base64 representation of the image.\n   */\n  base64?: string;\n  /**\n   * On Android and iOS this object may include various fields based on the device and operating system.\n   * On web, it is a partial representation of the [`MediaTrackSettings`](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings) dictionary.\n   */\n  exif?: Partial<MediaTrackSettings> | any;\n};\n\n// @needsAudit\nexport type CameraPictureOptions = {\n  /**\n   * Specify the quality of compression, from 0 to 1. 0 means compress for small size, 1 means compress for maximum quality.\n   */\n  quality?: number;\n  /**\n   * Whether to also include the image data in Base64 format.\n   */\n  base64?: boolean;\n  /**\n   * Whether to also include the EXIF data for the image.\n   */\n  exif?: boolean;\n  /**\n   * Additional EXIF data to be included for the image. Only useful when `exif` option is set to `true`.\n   * @platform android\n   * @platform ios\n   */\n  additionalExif?: { [name: string]: any };\n  /**\n   * A callback invoked when picture is saved. If set, the promise of this method will resolve immediately with no data after picture is captured.\n   * The data that it should contain will be passed to this callback. If displaying or processing a captured photo right after taking it\n   * is not your case, this callback lets you skip waiting for it to be saved.\n   * @param picture\n   */\n  onPictureSaved?: (picture: CameraCapturedPicture) => void;\n  // TODO(Bacon): Is it possible to implement this in the browser?\n  /**\n   * If set to `true`, camera skips orientation adjustment and returns an image straight from the device's camera.\n   * If enabled, `quality` option is discarded (processing pipeline is skipped as a whole).\n   * Although enabling this option reduces image delivery time significantly, it may cause the image to appear in a wrong orientation\n   * in the `Image` component (at the time of writing, it does not respect EXIF orientation of the images).\n   * > **Note**: Enabling `skipProcessing` would cause orientation uncertainty. `Image` component does not respect EXIF\n   * > stored orientation information, that means obtained image would be displayed wrongly (rotated by 90°, 180° or 270°).\n   * > Different devices provide different orientations. For example some Sony Xperia or Samsung devices don't provide\n   * > correctly oriented images by default. To always obtain correctly oriented image disable `skipProcessing` option.\n   */\n  skipProcessing?: boolean;\n  /**\n   * @platform web\n   */\n  scale?: number;\n  /**\n   * @platform web\n   */\n  imageType?: ImageType;\n  /**\n   * @platform web\n   */\n  isImageMirror?: boolean;\n  /**\n   * @hidden\n   */\n  id?: number;\n  /**\n   * @hidden\n   */\n  fastMode?: boolean;\n  /**\n   * @hidden\n   */\n  maxDownsampling?: number;\n};\n\n// @needsAudit\nexport type CameraRecordingOptions = {\n  /**\n   * Maximum video duration in seconds.\n   */\n  maxDuration?: number;\n  /**\n   * Maximum video file size in bytes.\n   */\n  maxFileSize?: number;\n  /**\n   * Specify the quality of recorded video. Use one of [`VideoQuality.<value>`](#videoquality).\n   * Possible values: for 16:9 resolution `2160p`, `1080p`, `720p`, `480p` : `Android only` and for 4:3 `4:3` (the size is 640x480).\n   * If the chosen quality is not available for a device, the highest available is chosen.\n   */\n  quality?: number | string;\n  /**\n   * If present, video will be recorded with no sound.\n   */\n  mute?: boolean;\n  /**\n   * If `true`, the recorded video will be flipped along the vertical axis. iOS flips videos recorded with the front camera by default,\n   * but you can reverse that back by setting this to `true`. On Android, this is handled in the user's device settings.\n   * @platform ios\n   */\n  mirror?: boolean;\n  /**\n   * Only works if `useCamera2Api` is set to `true`. This option specifies a desired video bitrate. For example, `5*1000*1000` would be 5Mbps.\n   * @platform android\n   */\n  videoBitrate?: number;\n  /**\n   * This option specifies what codec to use when recording the video. See [`VideoCodec`](#videocodec) for the possible values.\n   * @platform ios\n   */\n  codec?: VideoCodec;\n};\n\n/**\n * @hidden\n */\nexport type PictureSavedListener = (event: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) => void;\n\n/**\n * @hidden\n */\nexport type CameraReadyListener = () => void;\n\n/**\n * @hidden\n */\nexport type ResponsiveOrientationChangedListener = (event: {\n  nativeEvent: ResponsiveOrientationChanged;\n}) => void;\n\nexport type ResponsiveOrientationChanged = { orientation: CameraOrientation };\n\n/**\n * @hidden\n */\nexport type MountErrorListener = (event: { nativeEvent: CameraMountError }) => void;\n\n// @docsMissing\nexport type CameraMountError = { message: string };\n\n// @docsMissing\nexport type Point = {\n  x: number;\n  y: number;\n};\n\nexport type BarCodeSize = {\n  /**\n   * The height value.\n   */\n  height: number;\n  /**\n   * The width value.\n   */\n  width: number;\n};\n\n/**\n * These coordinates are represented in the coordinate space of the camera source (e.g. when you\n * are using the camera view, these values are adjusted to the dimensions of the view).\n */\nexport type BarCodePoint = Point;\n\nexport type BarCodeBounds = {\n  /**\n   * The origin point of the bounding box.\n   */\n  origin: BarCodePoint;\n  /**\n   * The size of the bounding box.\n   */\n  size: BarCodeSize;\n};\n\n// @needsAudit\nexport type BarCodeScanningResult = {\n  /**\n   * The barcode type.\n   */\n  type: string;\n  /**\n   * The information encoded in the bar code.\n   */\n  data: string;\n  /**\n   * Corner points of the bounding box.\n   * `cornerPoints` is not always available and may be empty. On iOS, for `code39` and `pdf417`\n   * you don't get this value.\n   */\n  cornerPoints: BarCodePoint[];\n  /**\n   * The [BarCodeBounds](#barcodebounds) object.\n   * `bounds` in some case will be representing an empty rectangle.\n   * Moreover, `bounds` doesn't have to bound the whole barcode.\n   * For some types, they will represent the area used by the scanner.\n   */\n  bounds: BarCodeBounds;\n};\n\nexport type FaceDetectionResult = {\n  /**\n   * Array of objects representing results of face detection.\n   * See [`FaceFeature`](facedetector/#facefeature) in FaceDetector documentation for more details.\n   */\n  faces: object[];\n};\n\n/**\n * @hidden\n */\nexport type ConstantsType = {\n  Type: CameraType;\n  FlashMode: FlashMode;\n  AutoFocus: AutoFocus;\n  WhiteBalance: WhiteBalance;\n  VideoQuality: VideoQuality;\n  VideoStabilization: VideoStabilization;\n  VideoCodec: VideoCodec;\n};\n\n// @needsAudit\nexport type CameraProps = ViewProps & {\n  /**\n   * Camera facing. Use one of `CameraType`. When `CameraType.front`, use the front-facing camera.\n   * When `CameraType.back`, use the back-facing camera.\n   * @default CameraType.back\n   */\n  type?: number | CameraType;\n  /**\n   * Camera flash mode. Use one of [`FlashMode.<value>`](#flashmode-1). When `FlashMode.on`, the flash on your device will\n   * turn on when taking a picture, when `FlashMode.off`, it won't. Setting to `FlashMode.auto` will fire flash if required,\n   * `FlashMode.torch` turns on flash during the preview.\n   * @default FlashMode.off\n   */\n  flashMode?: number | FlashMode;\n  /**\n   * Camera white balance. Use one of [`WhiteBalance.<value>`](#whitebalance). If a device does not support any of these values previous one is used.\n   * @default WhiteBalance.auto\n   */\n  whiteBalance?: number | WhiteBalance;\n  /**\n   * State of camera auto focus. Use one of [`AutoFocus.<value>`](#autofocus-1). When `AutoFocus.on`,\n   * auto focus will be enabled, when `AutoFocus.off`, it won't and focus will lock as it was in the moment of change,\n   * but it can be adjusted on some devices via `focusDepth` prop.\n   * @default AutoFocus.on\n   */\n  autoFocus?: boolean | number | AutoFocus;\n  /**\n   * A value between `0` and `1` being a percentage of device's max zoom. `0` - not zoomed, `1` - maximum zoom.\n   * @default 0\n   */\n  zoom?: number;\n  /**\n   * A string representing aspect ratio of the preview, eg. `4:3`, `16:9`, `1:1`. To check if a ratio is supported\n   * by the device use [`getSupportedRatiosAsync`](#getsupportedratiosasync).\n   * @default 4:3\n   * @platform android\n   */\n  ratio?: string;\n  /**\n   * Distance to plane of the sharpest focus. A value between `0` and `1` where: `0` - infinity focus, `1` - focus as close as possible.\n   * For Android this is available only for some devices and when `useCamera2Api` is set to `true`.\n   * @default 0\n   */\n  focusDepth?: number;\n  /**\n   * Callback invoked when camera preview has been set.\n   */\n  onCameraReady?: () => void;\n  /**\n   * Whether to use Android's Camera2 API. See `Note` at the top of this page.\n   * @platform android\n   */\n  useCamera2Api?: boolean;\n  /**\n   * A string representing the size of pictures [`takePictureAsync`](#takepictureasync) will take.\n   * Available sizes can be fetched with [`getAvailablePictureSizesAsync`](#getavailablepicturesizesasync).\n   */\n  pictureSize?: string;\n  /**\n   * The video stabilization mode used for a video recording. Use one of [`VideoStabilization.<value>`](#videostabilization).\n   * You can read more about each stabilization type in [Apple Documentation](https://developer.apple.com/documentation/avfoundation/avcapturevideostabilizationmode).\n   * @platform ios\n   */\n  videoStabilizationMode?: VideoStabilization;\n  /**\n   * Callback invoked when camera preview could not been started.\n   * @param event Error object that contains a `message`.\n   */\n  onMountError?: (event: CameraMountError) => void;\n  /**\n   * Settings exposed by [`BarCodeScanner`](bar-code-scanner) module. Supported settings: **barCodeTypes**.\n   * @example\n   * ```tsx\n   * <Camera\n   *   barCodeScannerSettings={{\n   *     barCodeTypes: [BarCodeScanner.Constants.BarCodeType.qr],\n   *   }}\n   * />\n   * ```\n   */\n  barCodeScannerSettings?: BarCodeSettings;\n  /**\n   * Callback that is invoked when a bar code has been successfully scanned. The callback is provided with\n   * an object of the [`BarCodeScanningResult`](#barcodescanningresult) shape, where the `type`\n   * refers to the bar code type that was scanned and the `data` is the information encoded in the bar code\n   * (in this case of QR codes, this is often a URL). See [`BarCodeScanner.Constants.BarCodeType`](bar-code-scanner#supported-formats)\n   * for supported values.\n   * @param scanningResult\n   */\n  onBarCodeScanned?: (scanningResult: BarCodeScanningResult) => void;\n  /**\n   * A settings object passed directly to an underlying module providing face detection features.\n   * See [`DetectionOptions`](facedetector/#detectionoptions) in FaceDetector documentation for details.\n   */\n  faceDetectorSettings?: object;\n  /**\n   * Callback invoked with results of face detection on the preview.\n   * See [`DetectionResult`](facedetector/#detectionresult) in FaceDetector documentation for more details.\n   * @param faces\n   */\n  onFacesDetected?: (faces: FaceDetectionResult) => void;\n  /**\n   * A URL for an image to be shown while the camera is loading.\n   * @platform web\n   */\n  poster?: string;\n  /**\n   * Whether to allow responsive orientation of the camera when the screen orientation is locked (i.e. when set to `true`\n   * landscape photos will be taken if the device is turned that way, even if the app or device orientation is locked to portrait)\n   * @platform ios\n   */\n  responsiveOrientationWhenOrientationLocked?: boolean;\n  /**\n   * Callback invoked when responsive orientation changes. Only applicable if `responsiveOrientationWhenOrientationLocked` is `true`\n   * @param event result object that contains updated orientation of camera\n   * @platform ios\n   */\n  onResponsiveOrientationChanged?: (event: ResponsiveOrientationChanged) => void;\n};\n\n/**\n * @hidden\n */\nexport type CameraNativeProps = {\n  pointerEvents?: any;\n  style?: any;\n  ref?: Function;\n  onCameraReady?: CameraReadyListener;\n  onMountError?: MountErrorListener;\n  onBarCodeScanned?: (event: { nativeEvent: BarCodeScanningResult }) => void;\n  onFacesDetected?: (event: { nativeEvent: FaceDetectionResult }) => void;\n  onFaceDetectionError?: (event: { nativeEvent: Error }) => void;\n  onPictureSaved?: PictureSavedListener;\n  onResponsiveOrientationChanged?: ResponsiveOrientationChangedListener;\n  type?: number | string;\n  flashMode?: number | string;\n  autoFocus?: string | boolean | number;\n  focusDepth?: number;\n  zoom?: number;\n  whiteBalance?: number | string;\n  pictureSize?: string;\n  barCodeScannerSettings?: BarCodeSettings;\n  faceDetectorSettings?: object;\n  barCodeScannerEnabled?: boolean;\n  faceDetectorEnabled?: boolean;\n  ratio?: string;\n  useCamera2Api?: boolean;\n  poster?: string;\n  responsiveOrientationWhenOrientationLocked?: boolean;\n};\n\n// @docsMissing\nexport type BarCodeSettings = {\n  barCodeTypes: string[];\n  interval?: number;\n};\n\nexport { PermissionResponse, PermissionStatus, PermissionExpiration, PermissionHookOptions };\n", "/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(props): Promise<any[]> {\n  const optionalSource = (id) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n", "import { UnavailabilityError } from 'expo-modules-core';\n\nimport {\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraType,\n  PermissionResponse,\n  PermissionStatus,\n} from './Camera.types';\nimport { ExponentCameraRef } from './ExponentCamera.web';\nimport {\n  canGetUserMedia,\n  isBackCameraAvailableAsync,\n  isFrontCameraAvailableAsync,\n} from './WebUserMediaManager';\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction handleGetUserMediaError({ message }: { message: string }): PermissionResponse {\n  // name: NotAllowedError\n  // code: 0\n  if (message === 'Permission dismissed') {\n    return {\n      status: PermissionStatus.UNDETERMINED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false,\n    };\n  } else {\n    // TODO: Bacon: [OSX] The system could deny access to chrome.\n    // TODO: Bacon: add: { status: 'unimplemented' }\n    return {\n      status: PermissionStatus.DENIED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: false,\n    };\n  }\n}\n\nasync function handleRequestPermissionsAsync(): Promise<PermissionResponse> {\n  try {\n    await getUserMedia({\n      video: true,\n    });\n    return {\n      status: PermissionStatus.GRANTED,\n      expires: 'never',\n      canAskAgain: true,\n      granted: true,\n    };\n  } catch ({ message }) {\n    return handleGetUserMediaError({ message });\n  }\n}\n\nasync function handlePermissionsQueryAsync(\n  query: 'camera' | 'microphone'\n): Promise<PermissionResponse> {\n  if (!navigator?.permissions?.query) {\n    throw new UnavailabilityError('expo-camera', 'navigator.permissions API is not available');\n  }\n\n  const { state } = await navigator.permissions.query({ name: query });\n  switch (state) {\n    case 'prompt':\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n  }\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentCameraManager';\n  },\n  get Type() {\n    return {\n      back: 'back',\n      front: 'front',\n    };\n  },\n  get FlashMode() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      torch: 'torch',\n    };\n  },\n  get AutoFocus() {\n    return {\n      on: 'on',\n      off: 'off',\n      auto: 'auto',\n      singleShot: 'singleShot',\n    };\n  },\n  get WhiteBalance() {\n    return {\n      auto: 'auto',\n      continuous: 'continuous',\n      manual: 'manual',\n    };\n  },\n  get VideoQuality() {\n    return {};\n  },\n  get VideoStabilization() {\n    return {};\n  },\n  async isAvailableAsync(): Promise<boolean> {\n    return canGetUserMedia();\n  },\n  async takePicture(\n    options: CameraPictureOptions,\n    camera: ExponentCameraRef\n  ): Promise<CameraCapturedPicture> {\n    return await camera.takePicture(options);\n  },\n  async pausePreview(camera: ExponentCameraRef): Promise<void> {\n    await camera.pausePreview();\n  },\n  async resumePreview(camera: ExponentCameraRef): Promise<void> {\n    return await camera.resumePreview();\n  },\n  async getAvailableCameraTypesAsync(): Promise<string[]> {\n    if (!canGetUserMedia() || !navigator.mediaDevices.enumerateDevices) return [];\n\n    const devices = await navigator.mediaDevices.enumerateDevices();\n\n    const types: (string | null)[] = await Promise.all([\n      (await isFrontCameraAvailableAsync(devices)) && CameraType.front,\n      (await isBackCameraAvailableAsync()) && CameraType.back,\n    ]);\n\n    return types.filter(Boolean) as string[];\n  },\n  async getAvailablePictureSizes(ratio: string, camera: ExponentCameraRef): Promise<string[]> {\n    return await camera.getAvailablePictureSizes(ratio);\n  },\n  /* async getSupportedRatios(camera: ExponentCameraRef): Promise<string[]> {\n    // TODO: Support on web\n  },\n  async record(\n    options?: CameraRecordingOptions,\n    camera: ExponentCameraRef\n  ): Promise<{ uri: string }> {\n    // TODO: Support on web\n  },\n  async stopRecording(camera: ExponentCameraRef): Promise<void> {\n    // TODO: Support on web\n  }, */\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    return handleRequestPermissionsAsync();\n  },\n  async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('camera');\n  },\n  async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return handleRequestPermissionsAsync();\n  },\n  async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return handlePermissionsQueryAsync('microphone');\n  },\n  async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      await getUserMedia({\n        audio: true,\n      });\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch ({ message }) {\n      return handleGetUserMediaError({ message });\n    }\n  },\n};\n", "/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport {\n  CameraType,\n  CameraCapturedPicture,\n  ImageSize,\n  ImageType,\n  WebCameraSettings,\n  CameraPictureOptions,\n} from './Camera.types';\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  invariant(\n    Object.values(ImageType).includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(\n      ImageType\n    ).join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === ImageType.jpg) {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config: CameraPictureOptions): CameraPictureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImageData(\n  video: HTMLVideoElement | null,\n  pictureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'> = {}\n): ImageData | null {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n\n  const context = canvas.getContext('2d', { alpha: false });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\n\nexport function captureImageContext(\n  video: HTMLVideoElement,\n  { scale = 1, isImageMirror = false }: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>\n): HTMLCanvasElement {\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale!);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', { alpha: false });\n\n  if (!context) {\n    // Should never be called\n    throw new Error('Context is not defined');\n  }\n  // sharp image details\n  // context.imageSmoothingEnabled = false;\n\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  return canvas;\n}\n\nexport function captureImage(\n  video: HTMLVideoElement,\n  pictureOptions: CameraPictureOptions\n): string {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const { imageType, quality = DEFAULT_QUALITY } = config;\n  return toDataURL(canvas, imageType!, quality);\n}\n\nfunction getSupportedConstraints(): MediaTrackSupportedConstraints | null {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  const preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  // TODO(Bacon): Test this\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        [key]: facingMode,\n      };\n    } else {\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType],\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input: any): input is MediaTrackConstraints {\n  return input && typeof input.video !== 'boolean';\n}\n\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    // A hack on desktop browsers to ensure any camera is used.\n    // eslint-disable-next-line no-undef\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType =\n        preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await requestUserMediaAsync(constraints);\n  return stream;\n}\n\nexport function isWebKit(): boolean {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\n\nexport function compareStreams(a: MediaStream | null, b: MediaStream | null): boolean {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\n\nexport function capture(\n  video: HTMLVideoElement,\n  settings: MediaTrackSettings,\n  config: CameraPictureOptions\n): CameraCapturedPicture {\n  const base64 = captureImage(video, config);\n\n  const capturedPicture: CameraCapturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0,\n  };\n\n  if (settings) {\n    const { width = 0, height = 0 } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\n\nexport async function syncTrackCapabilities(\n  cameraType: CameraType,\n  stream: MediaStream | null,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (stream?.getVideoTracks) {\n    await Promise.all(\n      stream.getVideoTracks().map((track) => onCapabilitiesReady(cameraType, track, settings))\n    );\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(\n  cameraType: CameraType,\n  track: MediaStreamTrack,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  const capabilities = track.getCapabilities();\n\n  // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n  const constraints: MediaTrackConstraintSet = {};\n\n  // TODO(Bacon): Add `pointsOfInterest` support\n  const clampedValues = [\n    'exposureCompensation',\n    'colorTemperature',\n    'iso',\n    'brightness',\n    'contrast',\n    'saturation',\n    'sharpness',\n    'focusDistance',\n    'zoom',\n  ];\n\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n\n  function validatedInternalConstrainedValue<IConvertedType>(\n    constraintKey: string,\n    settingsKey: string,\n    converter: (settingValue: any) => IConvertedType\n  ) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType,\n    });\n  }\n\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue<MediaTrackConstraintSet['focusMode']>(\n      'focusMode',\n      'autoFocus',\n      CapabilityUtils.convertAutoFocusJSONToNative\n    );\n  }\n\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue<MediaTrackConstraintSet['torch']>(\n      'torch',\n      'flashMode',\n      CapabilityUtils.convertFlashModeJSONToNative\n    );\n  }\n\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue<\n      MediaTrackConstraintSet['whiteBalanceMode']\n    >('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n\n  try {\n    await track.applyConstraints({ advanced: [constraints] });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\n\nexport function stopMediaStream(stream: MediaStream | null) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach((track) => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach((track) => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\n\nexport function setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof (video as any).mozSrcObject !== 'undefined') {\n    (video as any).mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream as MediaSource | Blob);\n  }\n\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? (video as any).mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\n\nexport function isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) {\n    return;\n  }\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue<T>(props: {\n  constraintKey: string;\n  settingsKey: string;\n  convertedSetting: T;\n  capabilities: MediaTrackCapabilities;\n  settings: WebCameraSettings;\n  cameraType: string;\n}): T | undefined {\n  const { constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType } =\n    props;\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    if (__DEV__) {\n      // Only warn in dev mode.\n      console.warn(\n        ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n      );\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}\n", "/*\n * Native web camera (Android) has a torch: boolean\n */\nexport function convertFlashModeJSONToNative(input: string): boolean {\n  switch (input) {\n    case 'torch':\n      return true;\n    case 'on':\n    case 'off':\n    case 'auto':\n    default:\n      return false;\n  }\n}\n\nexport function convertWhiteBalanceJSONToNative(input: string): MeteringMode | undefined {\n  switch (input) {\n    case 'on':\n    case 'auto':\n      return 'continuous';\n    case 'off':\n      return 'none';\n    case 'singleShot':\n      return 'single-shot';\n    default:\n      return undefined;\n  }\n}\n\nexport function convertAutoFocusJSONToNative(input: string): MeteringMode | undefined {\n  switch (input) {\n    case 'on':\n    case 'auto':\n      return 'continuous';\n    case 'off':\n      return 'manual';\n    case 'singleShot':\n      return 'single-shot';\n    default:\n      return undefined;\n  }\n}\n", "import { CameraType, ImageType } from './Camera.types';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/aspectRatio\nexport const VIDEO_ASPECT_RATIOS = {\n  '3840x2160': 3840 / 2160,\n  '1920x1080': 1920 / 1080,\n  '1280x720': 1280 / 720,\n  '640x480': 640 / 480,\n  '352x288': 352 / 288,\n};\n\nexport const PictureSizes = Object.keys(VIDEO_ASPECT_RATIOS);\n\nexport const ImageTypeFormat = {\n  [ImageType.jpg]: 'image/jpeg',\n  [ImageType.png]: 'image/png',\n};\n\nexport const MinimumConstraints: MediaStreamConstraints = {\n  audio: false,\n  video: true,\n};\n\nexport const CameraTypeToFacingMode = {\n  [CameraType.front]: 'user',\n  [CameraType.back]: 'environment',\n};\n\nexport const FacingModeToCameraType = {\n  user: CameraType.front,\n  environment: CameraType.back,\n};\n", "/* eslint-env browser */\nimport * as React from 'react';\n\nimport {\n  CameraReadyListener,\n  CameraType,\n  MountErrorListener,\n  WebCameraSettings,\n} from './Camera.types';\nimport * as Utils from './WebCameraUtils';\nimport { FacingModeToCameraType } from './WebConstants';\n\nconst VALID_SETTINGS_KEYS = [\n  'autoFocus',\n  'flashMode',\n  'exposureCompensation',\n  'colorTemperature',\n  'iso',\n  'brightness',\n  'contrast',\n  'saturation',\n  'sharpness',\n  'focusDistance',\n  'whiteBalance',\n  'zoom',\n];\n\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\n  React.useEffect(() => {\n    if (video) {\n      video.addEventListener('loadedmetadata', () => {\n        // without this async block the constraints aren't properly applied to the camera,\n        // this means that if you were to turn on the torch and swap to the front camera,\n        // then swap back to the rear camera the torch setting wouldn't be applied.\n        requestAnimationFrame(() => {\n          onLoaded();\n        });\n      });\n    }\n  }, [video]);\n}\n\nexport function useWebCameraStream(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  preferredType: CameraType,\n  settings: Record<string, any>,\n  {\n    onCameraReady,\n    onMountError,\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\n): {\n  type: CameraType | null;\n  mediaTrackSettings: MediaTrackSettings | null;\n} {\n  const isStartingCamera = React.useRef<boolean | null>(false);\n  const activeStreams = React.useRef<MediaStream[]>([]);\n  const capabilities = React.useRef<WebCameraSettings>({\n    autoFocus: 'continuous',\n    flashMode: 'off',\n    whiteBalance: 'continuous',\n    zoom: 1,\n  });\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\n\n  const mediaTrackSettings = React.useMemo(() => {\n    return stream ? stream.getTracks()[0].getSettings() : null;\n  }, [stream]);\n\n  // The actual camera type - this can be different from the incoming camera type.\n  const type = React.useMemo(() => {\n    if (!mediaTrackSettings) {\n      return null;\n    }\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\n    const { facingMode = 'user' } = mediaTrackSettings;\n    return FacingModeToCameraType[facingMode];\n  }, [mediaTrackSettings]);\n\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\n    try {\n      return await Utils.getPreferredStreamDevice(preferredType);\n    } catch (nativeEvent) {\n      if (__DEV__) {\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\n      }\n      if (onMountError) {\n        onMountError({ nativeEvent });\n      }\n      return null;\n    }\n  }, [preferredType, onMountError]);\n\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\n    const nextStream = await getStreamDeviceAsync();\n    if (Utils.compareStreams(nextStream, stream)) {\n      // Do nothing if the streams are the same.\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\n      // Without this check there is a screen flash while the video switches.\n      return false;\n    }\n\n    // Save a history of all active streams (usually 2+) so we can close them later.\n    // Keeping them open makes swapping camera types much faster.\n    if (!activeStreams.current.some((value) => value.id === nextStream?.id)) {\n      activeStreams.current.push(nextStream!);\n    }\n\n    // Set the new stream -> update the video, settings, and actual camera type.\n    setStream(nextStream);\n    if (onCameraReady) {\n      onCameraReady();\n    }\n    return false;\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\n\n  React.useEffect(() => {\n    // Restart the camera and guard concurrent actions.\n    if (isStartingCamera.current) {\n      return;\n    }\n    isStartingCamera.current = true;\n\n    resumeAsync()\n      .then((isStarting) => {\n        isStartingCamera.current = isStarting;\n      })\n      .catch(() => {\n        // ensure the camera can be started again.\n        isStartingCamera.current = false;\n      });\n  }, [preferredType]);\n\n  // Update the native camera with any custom capabilities.\n  React.useEffect(() => {\n    const changes: WebCameraSettings = {};\n\n    for (const key of Object.keys(settings)) {\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\n        continue;\n      }\n      const nextValue = settings[key];\n      if (nextValue !== capabilities.current[key]) {\n        changes[key] = nextValue;\n      }\n    }\n\n    // Only update the native camera if changes were found\n    const hasChanges = !!Object.keys(changes).length;\n\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\n    if (hasChanges) {\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\n    }\n\n    capabilities.current = nextWebCameraSettings;\n  }, [\n    settings.autoFocus,\n    settings.flashMode,\n    settings.exposureCompensation,\n    settings.colorTemperature,\n    settings.iso,\n    settings.brightness,\n    settings.contrast,\n    settings.saturation,\n    settings.sharpness,\n    settings.focusDistance,\n    settings.whiteBalance,\n    settings.zoom,\n  ]);\n\n  React.useEffect(() => {\n    // set or unset the video source.\n    if (!video.current) {\n      return;\n    }\n    Utils.setVideoSource(video.current, stream);\n  }, [video.current, stream]);\n\n  React.useEffect(() => {\n    return () => {\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\n      for (const stream of activeStreams.current) {\n        // Close all open streams.\n        Utils.stopMediaStream(stream);\n      }\n      if (video.current) {\n        // Invalidate the video source.\n        Utils.setVideoSource(video.current, stream);\n      }\n    };\n  }, []);\n\n  // Update props when the video loads.\n  useLoadedVideo(video.current, () => {\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\n  });\n\n  return {\n    type,\n    mediaTrackSettings,\n  };\n}\n", "import * as React from 'react';\n\nimport { BarCodeScanningResult, CameraPictureOptions, MountErrorListener } from './Camera.types';\nimport { captureImageData } from './WebCameraUtils';\n\nconst qrWorkerMethod = ({ data, width, height }: ImageData): any => {\n  // eslint-disable-next-line no-undef\n  const decoded = (self as any).jsQR(data, width, height, {\n    inversionAttempts: 'attemptBoth',\n  });\n\n  let parsed;\n  try {\n    parsed = JSON.parse(decoded);\n  } catch {\n    parsed = decoded;\n  }\n\n  if (parsed?.data) {\n    const nativeEvent: BarCodeScanningResult = {\n      type: 'qr',\n      data: parsed.data,\n      cornerPoints: [],\n      bounds: { origin: { x: 0, y: 0 }, size: { width: 0, height: 0 } },\n    };\n    if (parsed.location) {\n      nativeEvent.cornerPoints = [\n        parsed.location.topLeftCorner,\n        parsed.location.bottomLeftCorner,\n        parsed.location.topRightCorner,\n        parsed.location.bottomRightCorner,\n      ];\n    }\n    return nativeEvent;\n  }\n  return parsed;\n};\n\nconst createWorkerAsyncFunction = <T extends (data: any) => any>(fn: T, deps: string[]) => {\n  const stringifiedFn = [\n    `self.func = ${fn.toString()};`,\n    'self.onmessage = (e) => {',\n    '  const result = self.func(e.data);',\n    '  self.postMessage(result);',\n    '};',\n  ];\n\n  if (deps.length > 0) {\n    stringifiedFn.unshift(`importScripts(${deps.map((dep) => `'${dep}'`).join(', ')});`);\n  }\n\n  const blob = new Blob(stringifiedFn, { type: 'text/javascript' });\n  const worker = new Worker(URL.createObjectURL(blob));\n\n  // First-In First-Out queue of promises\n  const promises: {\n    resolve: (value: ReturnType<T>) => void;\n    reject: (reason?: any) => void;\n  }[] = [];\n\n  worker.onmessage = (e) => promises.shift()?.resolve(e.data);\n\n  return (data: Parameters<T>[0]) => {\n    return new Promise<ReturnType<T>>((resolve, reject) => {\n      promises.push({ resolve, reject });\n      worker.postMessage(data);\n    });\n  };\n};\n\nconst decode = createWorkerAsyncFunction(qrWorkerMethod, [\n  'https://cdn.jsdelivr.net/npm/jsqr@1.2.0/dist/jsQR.min.js',\n]);\n\nexport function useWebQRScanner(\n  video: React.MutableRefObject<HTMLVideoElement | null>,\n  {\n    isEnabled,\n    captureOptions,\n    interval,\n    onScanned,\n    onError,\n  }: {\n    isEnabled: boolean;\n    captureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>;\n    interval?: number;\n    onScanned?: (scanningResult: { nativeEvent: BarCodeScanningResult }) => void;\n    onError?: MountErrorListener;\n  }\n) {\n  const isRunning = React.useRef<boolean>(false);\n  const timeout = React.useRef<number | undefined>(undefined);\n\n  async function scanAsync() {\n    // If interval is 0 then only scan once.\n    if (!isRunning.current || !onScanned) {\n      stop();\n      return;\n    }\n    try {\n      const data = captureImageData(video.current, captureOptions);\n\n      if (data) {\n        const nativeEvent: BarCodeScanningResult | any = await decode(data);\n        if (nativeEvent?.data) {\n          onScanned({\n            nativeEvent,\n          });\n        }\n      }\n    } catch (error) {\n      if (onError) {\n        onError({ nativeEvent: error });\n      }\n    } finally {\n      // If interval is 0 then only scan once.\n      if (interval === 0) {\n        stop();\n        return;\n      }\n      const intervalToUse = !interval || interval < 0 ? 16 : interval;\n      // @ts-ignore: Type 'Timeout' is not assignable to type 'number'\n      timeout.current = setTimeout(() => {\n        scanAsync();\n      }, intervalToUse);\n    }\n  }\n\n  function stop() {\n    isRunning.current = false;\n    clearTimeout(timeout.current);\n  }\n\n  React.useEffect(() => {\n    if (isEnabled) {\n      isRunning.current = true;\n      scanAsync();\n    }\n\n    return () => {\n      if (isEnabled) {\n        stop();\n      }\n    };\n  }, [isEnabled]);\n}\n", "import { Platform } from 'expo-modules-core';\n\nimport {\n  CameraNativeProps,\n  CameraType,\n  FlashMode,\n  AutoFocus,\n  WhiteBalance,\n  CameraProps,\n} from '../Camera.types';\nimport CameraManager from '../ExponentCameraManager';\n\n// Values under keys from this object will be transformed to native options\nexport const ConversionTables: {\n  type: Record<keyof typeof CameraType, CameraNativeProps['type']>;\n  flashMode: Record<keyof typeof FlashMode, CameraNativeProps['flashMode']>;\n  autoFocus: Record<keyof typeof AutoFocus, CameraNativeProps['autoFocus']>;\n  whiteBalance: Record<keyof typeof WhiteBalance, CameraNativeProps['whiteBalance']>;\n} = {\n  type: CameraManager.Type,\n  flashMode: CameraManager.FlashMode,\n  autoFocus: CameraManager.AutoFocus,\n  whiteBalance: CameraManager.WhiteBalance,\n};\n\nexport function convertNativeProps(props?: CameraProps): CameraNativeProps {\n  if (!props || typeof props !== 'object') {\n    return {};\n  }\n\n  const nativeProps: CameraNativeProps = {};\n\n  for (const [key, value] of Object.entries(props)) {\n    if (typeof value === 'string' && ConversionTables[key]) {\n      nativeProps[key] = ConversionTables[key][value];\n    } else {\n      nativeProps[key] = value;\n    }\n  }\n\n  return nativeProps;\n}\n\nexport function ensureNativeProps(props?: CameraProps): CameraNativeProps {\n  const newProps = convertNativeProps(props);\n\n  if (newProps.onBarCodeScanned) {\n    newProps.barCodeScannerEnabled = true;\n  }\n\n  if (newProps.onFacesDetected) {\n    newProps.faceDetectorEnabled = true;\n  }\n\n  if (Platform.OS !== 'android') {\n    delete newProps.ratio;\n    delete newProps.useCamera2Api;\n  }\n\n  if (Platform.OS !== 'web') {\n    delete newProps.poster;\n  }\n\n  return newProps;\n}\n"],
  "mappings": "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",
  "names": ["React", "React", "CameraType", "FlashMode", "AutoFocus", "WhiteBalance", "ImageType", "VideoCodec", "VideoStabilization", "VideoQuality", "CameraOrientation", "sources", "getUserMedia", "invariant", "stream", "React", "_a", "_b"]
}
